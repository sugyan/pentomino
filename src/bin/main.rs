use std::array;

struct Solver {
    rows: usize,
    cols: usize,
    table: [[Vec<u64>; Self::NUM_PIECES]; 64],
}

impl Solver {
    const NUM_PIECES: usize = 12;
    const ALL_USED: u32 = (1 << Self::NUM_PIECES) - 1;

    fn new(rows: usize, cols: usize) -> Self {
        assert!(rows * cols <= 64);

        let shapes = [
            vec![
                [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)],
                [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],
            ],
            vec![
                [(0, 0), (1, 0), (0, 1), (1, 1), (0, 2)],
                [(0, 0), (1, 0), (2, 0), (1, 1), (2, 1)],
                [(1, 0), (0, 1), (1, 1), (0, 2), (1, 2)],
                [(0, 0), (1, 0), (0, 1), (1, 1), (2, 1)],
                [(0, 0), (1, 0), (0, 1), (1, 1), (1, 2)],
                [(1, 0), (2, 0), (0, 1), (1, 1), (2, 1)],
                [(0, 0), (0, 1), (1, 1), (0, 2), (1, 2)],
                [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1)],
            ],
            vec![
                [(0, 0), (1, 0), (1, 1), (1, 2), (1, 3)],
                [(3, 0), (0, 1), (1, 1), (2, 1), (3, 1)],
                [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3)],
                [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1)],
                [(0, 0), (1, 0), (0, 1), (0, 2), (0, 3)],
                [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1)],
                [(1, 0), (1, 1), (1, 2), (0, 3), (1, 3)],
                [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1)],
            ],
            vec![
                [(1, 0), (2, 0), (0, 1), (1, 1), (1, 2)],
                [(1, 0), (0, 1), (1, 1), (2, 1), (2, 2)],
                [(1, 0), (1, 1), (2, 1), (0, 2), (1, 2)],
                [(0, 0), (0, 1), (1, 1), (2, 1), (1, 2)],
                [(0, 0), (1, 0), (1, 1), (2, 1), (1, 2)],
                [(2, 0), (0, 1), (1, 1), (2, 1), (1, 2)],
                [(1, 0), (0, 1), (1, 1), (1, 2), (2, 2)],
                [(1, 0), (0, 1), (1, 1), (2, 1), (0, 2)],
            ],
            vec![
                [(2, 0), (3, 0), (0, 1), (1, 1), (2, 1)],
                [(0, 0), (0, 1), (0, 2), (1, 2), (1, 3)],
                [(1, 0), (2, 0), (3, 0), (0, 1), (1, 1)],
                [(0, 0), (0, 1), (1, 1), (1, 2), (1, 3)],
                [(0, 0), (1, 0), (1, 1), (2, 1), (3, 1)],
                [(1, 0), (0, 1), (1, 1), (0, 2), (0, 3)],
                [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1)],
                [(1, 0), (1, 1), (0, 2), (1, 2), (0, 3)],
            ],
            vec![
                [(0, 0), (1, 0), (2, 0), (1, 1), (1, 2)],
                [(2, 0), (0, 1), (1, 1), (2, 1), (2, 2)],
                [(1, 0), (1, 1), (0, 2), (1, 2), (2, 2)],
                [(0, 0), (0, 1), (1, 1), (2, 1), (0, 2)],
            ],
            vec![
                [(0, 0), (2, 0), (0, 1), (1, 1), (2, 1)],
                [(0, 0), (1, 0), (0, 1), (0, 2), (1, 2)],
                [(0, 0), (1, 0), (2, 0), (0, 1), (2, 1)],
                [(0, 0), (1, 0), (1, 1), (0, 2), (1, 2)],
            ],
            vec![
                [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)],
                [(0, 0), (1, 0), (2, 0), (0, 1), (0, 2)],
                [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)],
                [(2, 0), (2, 1), (0, 2), (1, 2), (2, 2)],
            ],
            vec![
                [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)],
                [(1, 0), (2, 0), (0, 1), (1, 1), (0, 2)],
                [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)],
                [(2, 0), (1, 1), (2, 1), (0, 2), (1, 2)],
            ],
            vec![[(1, 0), (0, 1), (1, 1), (2, 1), (1, 2)]],
            vec![
                [(2, 0), (0, 1), (1, 1), (2, 1), (3, 1)],
                [(0, 0), (0, 1), (0, 2), (1, 2), (0, 3)],
                [(0, 0), (1, 0), (2, 0), (3, 0), (1, 1)],
                [(1, 0), (0, 1), (1, 1), (1, 2), (1, 3)],
                [(1, 0), (0, 1), (1, 1), (2, 1), (3, 1)],
                [(0, 0), (0, 1), (1, 1), (0, 2), (0, 3)],
                [(0, 0), (1, 0), (2, 0), (3, 0), (2, 1)],
                [(1, 0), (1, 1), (0, 2), (1, 2), (1, 3)],
            ],
            vec![
                [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)],
                [(2, 0), (0, 1), (1, 1), (2, 1), (0, 2)],
                [(1, 0), (2, 0), (1, 1), (0, 2), (1, 2)],
                [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)],
            ],
        ];
        let mut table = array::from_fn(|_| array::from_fn(|_| Vec::new()));
        for (n, shape) in shapes.iter().enumerate() {
            for s in shape {
                let v = s.iter().map(|p| (1 << (p.0 + p.1 * cols))).sum::<u64>();
                let w = s.iter().map(|(x, _)| x).max().unwrap();
                let h = s.iter().map(|(_, y)| y).max().unwrap();
                for i in 0..cols - w {
                    for j in 0..rows - h {
                        let offset = i + j * cols;
                        table[s[0].0 + offset][n].push(v << offset);
                    }
                }
            }
        }
        Self { rows, cols, table }
    }

    fn solve(&self, start: u64) {
        self.backtrack(start, 0, &mut Vec::with_capacity(Self::NUM_PIECES));
    }
    fn backtrack(&self, current: u64, used: u32, path: &mut Vec<(usize, u64)>) -> bool {
        if used == Self::ALL_USED {
            return self.found(path);
        }
        let target = current.trailing_ones() as usize;
        for (i, candidate) in self.table[target].iter().enumerate() {
            if used & (1 << i) == 0 {
                for &c in candidate.iter() {
                    if current & c == 0 {
                        path.push((i, c));
                        if self.backtrack(current | c, used | (1 << i), path) {
                            return true;
                        }
                        path.pop();
                    }
                }
            }
        }
        false
    }
    fn found(&self, path: &[(usize, u64)]) -> bool {
        for y in 0..self.rows {
            for x in 0..self.cols {
                let v = 1 << (x + y * self.cols);
                if let Some(i) =
                    path.iter().enumerate().find_map(
                        |(i, &(_, p))| {
                            if p & v != 0 {
                                Some(i as u8)
                            } else {
                                None
                            }
                        },
                    )
                {
                    print!("\x1b[{}m  \x1b[0m", 41 + (i % 7));
                } else {
                    print!("  ");
                }
            }
            println!();
        }
        println!();
        false
    }
}

fn main() {
    let solver = Solver::new(8, 8);
    let start = [27, 28, 35, 36].iter().map(|&p| 1 << p).sum::<u64>();
    // let solver = Solver::new(6, 10);
    // let start = 0;
    solver.solve(start);
}
